---
title: "TMA4250-Project-2"
author: "Ole Riddervold, Ole Kristian Skogly"
date: "2023-03-06"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# install.packages("ggnewscale")
# install.packages("scales")

library(spatial)
library(MASS)
library(ggplot2)
library(patchwork)
library(glue)
library(tidyverse)
library(reshape2)
library(ggnewscale)
library(scales)
```


## Loading data
```{r}
cells   <- read.table("data/cells.dat", skip=3, col.names=c('x', 'y'))
redwood <- read.table("data/redwood.dat", skip=3, col.names=c('x', 'y'))
pines   <- read.table("data/pines.dat", skip=3, col.names=c('x', 'y'))
```

## Exploring data
```{r}
head(cells)
head(redwood)
head(pines)
```


# Problem 1
## a)
```{r}
display_point_patterns <- function(dataframes, titles) {
  # Plots point patterns for dataframes with point data
  # Args: Dataframes and titles as lists of the same lengths
  # Returns: None
  n <- length(dataframes)
  do.call(
    wrap_plots,
    lapply(1:n, function(i) {
      ggplot(dataframes[[i]]) + geom_point(aes(x, y), size=1) +
        xlab('x') + ylab('y') + labs(title=titles[i]) +
        coord_fixed()
    })
  )
}
```

```{r}
plot_titles = c(
  "Cells",
  "Redwood",
  "Pines"
)

# png("figures/1_a.png", width=3600, height=1200, units="px", res=300) # Saving

display_point_patterns(list(
  cells,
  redwood,
  pines
), plot_titles)
```
For the Cells dataset, the points seem to be uniformly spread across the whole window. This would make sense since cells exist in very large quantities, and repel each other to a certain degree (https://www.hcplive.com/view/cells_repel). This will result in a uniform distribution of points when we pick a small window.

Comparing the last two dataset, it is evident that redwood trees have a tendency to grow in clusters along streams and other bodies of water (https://www.fs.usda.gov/research/treesearch/41153), which is very evident in the point patern plotted above. Pines, however, tend to follow a more random pattern of growth (https://www.researchgate.net/publication/227015905_The_problem_of_accuracy_in_environmental_analysis), giving the random pattern that is seen in the rightmost plot of Figure (FIGREF).

## b)
The L-function is defined by
\begin{equation}
  L(r) = \sqrt[d]{\frac{K(r)}{b_d}}
\end{equation}

where
\begin{align}
  K(r) &= \frac{1}{\lambda}\mathbb{E}_\mathbf{0}\left[N\left(B_r(\mathbf{0}\backslash\{\mathbf{0}\})\right)\right] \\
  b_d = \nu(B_1(\mathbf{0}))
\end{align},
$B_r(\mathbf{x})$ denotes a ball of radius $r$ centered in $\mathbf{x}$ in the relevant space (here $\mathbb{R}^2$), and $\nu$ denotes the volume-function. The K-function $K(r)$ can be interpreted as the ratio between the expected number of points in a ball centered at $\mathbf{0}$ excluding the origin itself, *given* that there is a point at the origin, and the rate of the point process itself. Therefore one can say that the L-function is a variant of the K-function that takes the curse of dimensionality, i.e. the fact that points get further apart the larger the dimension, into account. In $\mathbb{R}^2$, we have
\begin{equation}
  L(r) = \sqrt(\frac{K(r)}{\pi})
\end{equation}

Estimation of the L-function:
```{r}
pp.cells   <- ppinit("data/cells.dat")
pp.redwood <- ppinit("data/redwood.dat")
pp.pines   <- ppinit("data/pines.dat")

L.cells   <- data.frame(Kfn(pp.cells, fs=1.0)[1:2])
L.redwood <- data.frame(Kfn(pp.redwood, fs=1.0)[1:2])
L.pines   <- data.frame(Kfn(pp.pines, fs=1.0)[1:2])
```

L-function plotting:
```{r}
display_L_functions <- function(dataframes, titles) {
  # Plots K-functions and affine lines with growth 1 for comparison
  # Args: Dataframes and titles as same length lists
  # Returns: None
  n <- length(dataframes)
  do.call(
    wrap_plots,
    lapply(1:n, function(i) {
      ni <- nrow(dataframes[[i]])
      df <- dataframes[[i]] %>% mutate(xline=1:ni/100, yline=1:ni/100)
      ggplot(df) + geom_point(aes(x, y), size=1, col="red") +
        xlab('x') + ylab('y') + labs(title=titles[i]) +
        geom_line(aes(xline, yline)) +
        coord_fixed()
    })
  )
}
```


```{r}
# png("figures/1_b.png", width=3600, height=1200, units="px", res=300) # Saving

display_L_functions(list(
  L.cells,
  L.redwood,
  L.pines
), titles=plot_titles)
```

If, for small distances, the L-function diverges from the theoretical straight function (a straight line), then that is a implication that there is either clustering or repulsion in the dataset. For each of the datasets provided:
- Cells: The L-function goes below the theoretical L-function, meaning that there are fewer points than expected in the ball with small $r$. This implies that there is repulsion in the point process, and a Gibbs process might be more suitable.
- Redwood: The L-function is slightly higher than the theoretical function for small $r$, which is an implication of clustering, as discussed in 1a), and a Neymann-Scott process may therefore be more suitable.
- Pines: The estimated L-function is mostly a straight line corresponding to the theoretical function, implying that a Poisson point process is a suitable model.


## c)
For a homogeneous Poisson point process on a window $W\subseteq \mathbb{R}^m$, we have the convenient result:
\begin{equation}
  \left[\mathbf{x}_1. \cdots, \mathbf{x}_n | N(W)=n\right] \overset{\text{i.i.d.}}{\sim} U(W)
\end{equation}

In this case, $m=2$ and $W=[0, 1]\times[0, 1]$. The points are therefore very easy to simulate, as they follow a uniform distribution on $W$.
```{r}
simulate_R2_unif <- function(n, m) {
  # Simulates a homogeneous Poisson point process on R^2 in m realizations on [0, 1]x[0, 1].
  # Args: n (amount of points to simulate in each realization) and m (amount of realizations)
  # Returns: mxnx2 array.
  dims <- c(m, n, 2)
  realizations <- array(runif(m*n*2), dims)
  return(realizations)
}
```

```{r}
calculate_R2_L_functions <- function(realizations) {
  # Given realizations of some point process in the form of an array, calculates
  # the L-function for each realiztion and returns as an array.
  # Args: realizations (mxnx2 array)
  #         - m: Amount of realzations
  #         - n: Amount of points per realization
  # Returns: mxn-array
  d <- dim(realizations)
  L <- array(rep(0, prod(d[1:2])), d[1:2])
  for (i in 1:d[1]) {
    df <- data.frame(realizations[i, , ])
    colnames(df) <- c('x', 'y')
    L[i, ] <- Kfn(df, fs=1.0)$y
  }
  return(L)
}
```

```{r}
R2_L_function_stats <- function(L_functions) {
  # Given an array of m L-functions at n points, calculates mean and 90%
  # confidence intervals.
  # Args: L_functions (mxn)
  # Returns: Dataframe of L-functions
  stats <- L_functions %>% melt() %>%
    group_by(Var2) %>%
    summarize(
      mean=mean(value),
      CI90=qt(0.05, length(value))*sd(value)*sqrt(1 + 1/length(value))
    )
  return(stats)
}
```

```{r}
simulate_R2_ppp_Lfn <- function(n, m) {
  # Simulates a Poisson point process conditional on N = n, and returning
  # a dataframe containing empirically estimated L-function and 90% CI.
  return(
    simulate_R2_unif(n, m) %>%
      calculate_R2_L_functions() %>%
      R2_L_function_stats()
  )
}
```

```{r}
display_L_functions_with_ppp_sim <- function(dataframes, titles, m=100) {
  # Plots K-functions and affine lines with growth 1 for comparison
  # Args: Dataframes and titles as same length lists
  # Returns: None
  n <- length(dataframes)
  do.call(
    wrap_plots,
    lapply(1:n, function(i) {
      ni <- nrow(dataframes[[i]])
      simi <- simulate_R2_ppp_Lfn(n=ni, m=m)
      df <- dataframes[[i]] %>% mutate(Lmean=simi$mean, LCI=simi$CI90)
      ggplot(df) + geom_point(aes(x, y), size=1, col="red") +
        geom_line(aes(x, Lmean)) +
        geom_ribbon(aes(x, ymin=Lmean-LCI, ymax=Lmean+LCI), alpha=0.25) +
        xlab('x') + ylab('y') + labs(title=titles[i]) +
        coord_fixed()
    })
  )
}
```

```{r}
png("figures/1_c.png", width=3600, height=1200, units="px", res=300) # Saving

display_L_functions_with_ppp_sim(list(
  L.cells,
  L.redwood,
  L.pines
), titles=plot_titles)
```


# Problem 2
## a)
```{r}
obspines <- read.table("data/obspines.txt", skip=1, col.names=c('x', 'y', 'obs'))
obsprob <- read.table("data/obsprob.txt", skip=1, col.names=c('x', 'y', 'prob'))
```


```{r}
# png("figures/2_a1.png", width=1200, height=1200, units="px", res=300) # Saving
ggplot(obspines) +
  geom_tile(aes(x, y, fill=obs)) + scale_fill_gradient(low="white", high="purple") +
  xlab('x [m]') + ylab('y [m]') + 
  coord_fixed()

# png("figures/2_a2.png", width=1200, height=1200, units="px", res=300) # Saving
ggplot(obsprob) + 
  geom_tile(aes(x, y, fill=prob)) + scale_fill_gradient(low='white', high='darkgreen') + 
  xlab('x [m]') + ylab('y [m]') +
  coord_fixed()
```


## b)
Assuming that the pine trees follow a Poisson point process, which supports the conclusions made in 1). It can be proved that if $\alpha: W \rightarrow[0,1]$ denotes detection probabilities on $W$ (which in this case is defined as $W = [0, 300]\times[0, 300]$), and $N(\mathbf{x})$ is a homogeneous Poisson P.P. with rate $\lambda_N$ then the observed points $M(\mathbf{x})$ follow an inhomogeneous Poisson P.P. with rate given by
\begin{equation}
  \lambda_M(\mathbf{x}) = \lambda_N \alpha(\mathbf{x}) \: \:\forall \: \mathbf{x} \in W
\end{equation}
Thus, we get that
\begin{align}
  M | N &\sim \mathrm{Poisson}(\nu_{\lambda_M}(W)) \\
  \nu_{\lambda_M}(W) &= \lambda_N\int_W{\alpha_(\mathbf{x})\mathrm{d}\mathbf{x}}
\end{align}
Consequently, the point locations are distributed uniformly with pdf
\begin{equation}
  f(\mathbf{x}_1, \cdots, \mathbf{x}_m | M(W)=m) = \prod_{i=1}^m{\frac{\lambda_M(\mathbf{x}_i)}{\nu_{\lambda_M}(W)}} = \left(\frac{\lambda_N}{\nu_{\lambda_M}(W)}\right)^m\prod_{i=1}^m{\alpha(\mathbf{x}_i)}
\end{equation}

## c)
We want to determine $C$ such that
\begin{equation}
  \hat{\Lambda} = \frac{1}{C}\sum_{i, j}{M_{ij}}
\end{equation}
is unbiased.

Estimate from data:
```{r}
remote_estimate_lambda <- function(obs, prob, grid_size) {
  # Estimates lambda based on observed points and detection probabilities
  # Args: obs (Amount of observations in a gridpoint), alpha (detection probabilities)
  # Returns: (float) Estimate of lambda
  C <- grid_size*sum(prob) # Normalizing constant
  lambda_hat <- sum(obs)/C
  return(lambda_hat)
}
```

```{r}
grid_size <- 10^2 # For this particular problem
lambda_hat <- remote_estimate_lambda(obspines$obs, obsprob$prob, grid_size)
lambda_hat
```

With the given data, the estimate is approximately $\hat{\lambda}_N = 0.0104$.

The following algorithm takes a grid in the form of a dataframe with x- and y-coordinates and corresponding rate $\lambda$, and simulates a homogeneous P.P.P. in each point using the rate.

```{r}
simulate_ppp_on_grid <- function(grid, cell_size, poisson_displacement=0) {
  # Simulates a inhomogeneous Poisson point process on a square grid.
  # Args:
  #   grid  (Dataframe): Coordinates and rate (columns x, y, lambda)
  #   cell_size (float): Length of the given cell
  # Returns:
  #   Matrix of points
  k <- nrow(grid)
  n <- rpois(k, grid$lambda*cell_size^2) + poisson_displacement # n for every point
  points <- array(
    runif(2*sum(n), min=0, max=cell_size),
    c(sum(n), 2)
  ) %>% data.frame()
  colnames(points) <- c('x', 'y')

  # Adding x- and y-values to each point:
  ind <- 0
  for (i in 1:k) {
    if (n[i] > 0) {
      for (j in 1:n[i]) {
        points$x[ind+j] <- points$x[ind+j] + grid$x[i]
        points$y[ind+j] <- points$y[ind+j] + grid$y[i]
      }
      ind <- ind + n[i]
    }
  }
  return(points)
}
```

```{r}
grid <- obsprob %>% select(c('x', 'y')) %>% mutate(lambda=lambda_hat)
points_homogeneous_ppp <- replicate(3, simulate_ppp_on_grid(grid, cell_size=10), simplify=FALSE)
```

```{r}
# png("figures/2_c.png", width=1200, height=1200, units="px", res=300) # Saving

display_point_patterns(
  points_homogeneous_ppp,
  titles=c("", "", "")
)
```

## d)
```{r}
grid <- obsprob %>% mutate(lambda=lambda_hat*(1-prob)) %>% select(-prob)
m <- nrow(obspines %>% subset(obs > 0)) # THIS NEEDS TO BE A LIST OR DATAFRAME
points_inhomogeneous_ppp <- replicate(3, simulate_ppp_on_grid(grid, cell_size=10, poisson_displacement=m), simplify=FALSE)
```

```{r}
# png("figures/2_d.png", width=1200, height=1200, units="px", res=300) # Saving

display_point_patterns(
  points_inhomogeneous_ppp,
  titles=c("", "", "")
)
```

